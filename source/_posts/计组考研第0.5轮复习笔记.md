---
title: 计组考研第0.5轮复习笔记
category: 笔记
tags:
  - 考研
  - 计组
banner_img: /img/banner/jizu_preview.jpg
index_img: /img/cover/jizu_preview.jpg
excerpt: 王道计组考研视频笔记总结
date: 2022-12-28 20:48:19
---

## 第一章 计算机系统概述
### 硬件结构
![](/img/content/jizu_preview/hardware_structure.jpg)

### 知识点
- 软件和硬件逻辑等效
- 软件功能可以被硬件取代
- 编译的速度比解释快
- 相联存储器既可按地址寻址又可按内容寻址
- CPI：执行一条指令平均使用的CPU时钟数
- CPI与系统结构、指令集、计算机组织有关
- CPU主频：CPU时钟脉冲频率
- 数据字长：数据总线一次能并行传送数据的位数，不等于MDR
- MFLOPS：每秒执行多少百万次浮点运算
- GFLOPS：每秒执行多少十亿次浮点运算
- TFLOPS：每秒执行多少万亿次浮点运算
- 对用户透明=用户不可见

## 第二章 数据的表示和运算
### 原码、反码、补码、移码的基本信息
![](/img/content/jizu_preview/form_info.jpg)

### 算数移位
左移为乘法，右移为除法
![](/img/content/jizu_preview/login_translocation.jpg)

### 循环移位
不带进位的循环移位就是先将尾数循环一圈，然后将出来的那一位送入标志位中
带进位的循环移位就是将整个看成整体转一圈
![](/img/content/jizu_preview/circle_translocat.jpg)

### 符号扩展
整数在左边添加位，小数在右边添加位
反码不论整数和小数都添加1
补码整数在左边添加，相当于尾数右移，左边填充1
补码小数在右边添加，相当于尾数左移，右边填充0
![](/img/content/jizu_preview/flag_extention.jpg)

### 原码一位乘法
1. 取被乘数和乘数的绝对值$|x|$和$|y|$，符号位单独处理（符号位用一位或两位均可）
2. 被乘数符号位参与运算，乘数符号位不参与运算
3. 初始时，乘数=|y|
4. 乘数最低位=1，+|x|，部分积逻辑右移：左边补0
5. 乘数最低位=0，+0，部分积逻辑右移
6. 经过n轮加法和n轮移位
7. 最终结果：符号位=$x_0\bigoplus y_0$，部分积为乘积的高位，乘数为乘积的低位

![](/img/content/jizu_preview/yuanma_chengfa.jpg)

### 补码一位乘法：Booth算法
1. 取被乘数的补码和被乘数负数的补码以及乘数的补码$[x]_补、[-x]_补、[y]_补$，符号位通过计算得出，不单独处理
2. 被乘数和乘数符号位都参与运算
3. 初始时，乘数=$[y]_补$，辅助位=0
4. 商位数=余数位数=n+1
5. 辅助位-乘数最低位=1，+$[x]_补$，部分积算术右移：符号位不动，数值位右移，正数补0，负数补1
6. 辅助位-乘数最低位=0，+$0$，部分积算术右移
7. 辅助位-乘数最低位=-1，+$[-x]_补$，部分积算术右移
8. 经过n+1轮加法和n轮移位
9. 最终结果：部分积符号位为乘积的符号位，部分积数值部分为乘积的高位，乘数前n位为乘积的低位

![](/img/content/jizu_preview/booth.jpg)
（符号位用一位或两位均可）

### 原码除法：恢复余数法
1. 取被除数和除数的绝对值|x|、|y|以及除数绝对值的补码和绝对值负数的补码$[|y|]_补、[-|y|]_补$，符号位单独处理
2. 被除数符号位参与运算
3. 初始时，被除数=|x|
4. 商位数=余数位数=n+1
5. +$[-|y|]_补$，余数为负，商0，+$[|y|]_补$，逻辑左移：整体向左移，右边补0
6. +$[-|y|]_补$，余数为正，商1，逻辑左移
7. 直到商有n+1位结束，最后一次+$[-|y|]_补$操作后不需要移位
8. 最终结果：商的符号=$x_0\bigoplus y_0$，商=n+1位商，余数=被除数$\times 2^{-n}$

![](/img/content/jizu_preview/huifuyushu.jpg)

### 原码除法：加减交替法（不恢复余数法）
1. 取被除数和除数的绝对值|x|、|y|以及除数绝对值的补码和绝对值负数的补码$[|y|]_补、[-|y|]_补$，符号位单独处理
2. 被除数符号位参与运算
3. 初始时，被除数=|x|
4. 首先+$[-|y|]_补$
5. 余数为负，商0，逻辑左移：整体向左移，右边补0，+$[|y|]_补$
6. 余数为正，商1，逻辑左移，+$[-|y|]_补$
7. 经过n+1轮加法和n轮移位
8. 最终结果：商的符号=$x_0\bigoplus y_0$，商=n+1位商，余数=被除数$\times 2^{-n}$
9. 当n+1步余数为负时，+|y|恢复余数

![](/img/content/jizu_preview/jiajianjiaoti.jpg)

### 补码除法：加减交替法
1. 取被除数的补码和除数的补码以及除数的负数的补码$[x]_补、[y]_补、[-y]_补$，符号位通过计算得出，不单独处理
2. 被除数符号位参与运算
3. 初始时，被除数=$[x]_补$
4. 商位数=余数位数=n+1
5. 首先，被除数与除数同号则+$[-y]_补$；异号则+$[y]_补$
6. 余数和除数同号，商1，逻辑左移：整体向左移，右边补0，+$[-y]_补$
7. 余数和除数异号，商0，逻辑左移，+$[y]_补$
8. 经过n+1轮加法和n轮移位
9. 末位商横置1
8. 最终结果：商=n+1位商，余数=被除数$\times 2^{-n}$

![](/img/content/jizu_preview/bumachufa.jpg)

### IEEE 754标准
- 只需记住单精度浮点型float
- 最高位为数符位，8位阶码（移码表示），23位尾数（原码表示）
- 尾数隐藏最高位1，表示尾数1.M
- 计算阶码的真值时，需在原来的基础上+1
- 阶码中全0和全1用作其他用途，见下图
- 阶码最小值：0111,1111=-126；阶码最大值：1111,1110=127

这块好复杂，没太搞懂，贴个链接下次再看：[王道计组考研_IEEE](https://www.bilibili.com/video/BV1BE411D7ii?p=25&vd_source=26c95e35cccd29bb6633b68242402e97)
![](/img/content/jizu_preview/ieee.jpg)
![](/img/content/jizu_preview/ieee_range.jpg)

### 浮点数尾数规格化
左规：最高位不是有效位，将尾数算数左移n位直到最高位为有效位，阶码-n
右规：尾数溢出（双符号位为01/10），将尾数算数右移一位，阶码+1
$
\begin{array}{|c|c|c|c|c|}
	\hline 尾数类型&最高位&表示范围&最小值&最大值\\
	\hline 原码正数&0.1XX&\frac{1}{2}\leq M\leq(1-2^{-n})&0.100&0.111\\
	\hline 原码负数&1.1XX&-(1-2^{-n})\leq M\leq-\frac{1}{2}&1.111&1.100\\
	\hline 补码正数&0.1XX&\frac{1}{2}\leq M\leq(1-2^{-n})&0.100&0.111\\
	\hline 补码负数&1.0XX&-1\leq M\leq-(\frac{1}{2}+2^{-n})&1.011&1.000\\
	\hline
\end{array}
$

### 浮点数运算
步骤如下：
1. 对阶：将小阶向大阶对齐
2. 尾数加减
3. 规格化：进行左规或右规使尾数规格化
4. 舍入：
	- 0舍1入法
	- 恒置1法
5. 溢出判断：观察阶码是否溢出

![](/img/content/jizu_preview/fudianjiajian.jpg)

### 知识点
- 补码和真值对应关系不如原码和真值对应关系简单直观
- 双符号位补码=模4补码
- 单符号位补码=模2补码
- C语言中定点整数使用补码存储
- char占1个字节
- short占2个字节
- int占4个字节
- double占8个字节
- ALU由组合逻辑电路构成
- 串行加法器中，低位进位时间影响运算时间
- 并行加法器中：进位信号$g=X_i\times Y_i$，进位传递信号$p=X_i\bigoplus Y_i$
- 模4补码存储只需要1个符号位，只在ALU中参与运算时使用双符号位
- 当补码左移时，符号位$X_0$=最高位$X_1$时溢出
- 原码乘法：n次加法、n次移位；补码乘法：n+1次加法、n次移位
- 在原码不恢复余数除法中，仅当最终余数为负时恢复余数
- 计算补码减法x-y时，若y为正数，则$[x]_补+[-y]_补$，在加法器中输入端为y的反码，低位进位=1
- 边界对齐方式中，半字地址是2的整数倍，字地址是4的整数倍，因此行首的第一个字节后必须空一个字节才继续存储一个半字
- 浮点数中，阶码位数反映浮点数表示范围；尾数位数反映浮点数精度
- 强制类型转换：char->int->long->double，float->double
- 浮点数的基数越大，表示范围越大，精度越小
- 8421是十进制编码，不是二进制数
- 浮点运算的下溢是值：结果的绝对值小于机器能表示的最小绝对值
- 舍入是浮点数的概念，定点数没有舍入
- 两种情况下要舍入：对阶和右规
- 对阶操作不会引起阶码上溢和下溢
- 右规和尾数舍入可能引起阶码上溢

## 第三章 存储系统

### 存储器分类
![](/img/content/jizu_preview/store_sort.jpg)

### 三级存储系统的层次结构
CPU可直接与Cache和主存进行信息交换
![](/img/content/jizu_preview/store_level.jpg)
![](/img/content/jizu_preview/store_struction.jpg)

### RAM和ROM分类
![](/img/content/jizu_preview/ram_rom.jpg)

### DRAM和SRAM比较
$
\begin{array}{|c|c|c|}
	\hline 特点&SRAM&DRAM\\
	\hline 存储信息&触发器&电容\\
	\hline 破坏性读出&不是&是\\
	\hline 需要刷新&不要&需要\\
	\hline 送行列地址&同时送&分两次送\\
	\hline 运行速度&快&慢\\
	\hline 集成度&低&高\\
	\hline 发热量&大&小\\
	\hline 存储成本&高&低\\
	\hline
\end{array}
$

### DRAM的刷新
- 不需要CPU控制
- 刷新占1个存储周期
- 每次刷新一行存储单元（仅需行地址）
- 三种刷新方式：分散刷新、集中刷新、异步刷新

![](/img/content/jizu_preview/dram_refresh.jpg)

### 双端口RAM
- 两个端口对同一个地址同时写，发生冲突
- 两个端口对同一个地址一个写，一个读，发生冲突
- 解决办法：置忙信号

![](/img/content/jizu_preview/double_ram.jpg)

### 多体并行存储器
- 低位交叉编制中，连续存储n个存储字耗时$T+(n-1)\tau$
- 存储体数量m$\geq$存储周期T$\div$总线传输周期$\tau$

![](/img/content/jizu_preview/multi_module.jpg)
![](/img/content/jizu_preview/duoti.jpg)

### Cache的计算
- $命中率h=命中Cache的次数\div 命中主存的次数$
- $平均访问时间T_a=命中率\times 命中Cache的访问时间+(1-命中率)\times 命中主存的访问时间$
- $效率e=\frac{命中Cache的访问时间}{平均访问时间}$

![](/img/content/jizu_preview/cache.jpg)

### 地址映射
![](/img/content/jizu_preview/address_mapping.jpg)
*全相联映射：*
$$
\begin{array}{|c|c|}
	\hline 主存字块标记&字块内地址\\
	\hline 主存位数-块内地址&字块大小的位数\\
	\hline
\end{array}
$$
*直接映射：*
$$
\begin{array}{|c|c|c|}
	\hline 主存字块标记&Cache字块地址&字块内地址\\
	\hline 主存位数-Cache块地址-块内地址&Cache字块数的位数&字块大小的位数\\
	\hline
\end{array}
$$
*组相联映射：*
$$
\begin{array}{|c|c|c|}
	\hline 主存字块标记&组地址&字块内地址\\
	\hline 主存位数-组地址-块内地址&组大小的位数&字块大小的位数\\
	\hline
\end{array}
$$

### 固态硬盘SSD
- 基于闪存的存储器，和U盘没区别
- 随机写较慢，但随机读写性能高于磁盘
- 缺点是容易磨损

### 磁盘存储器
- 最小读写单位是扇区
- 未格式化的硬盘容量>格式化后的实际容量
- 扇区中包含数据、地址、校验等信息
- 磁盘存储器由磁盘控制器、磁盘驱动器、盘片组成
- 存取时间=寻道时间+延迟时间+传输时间

### RAID技术
- 将多个五里盘组成一个逻辑盘，具有更好的存储性能、可靠性和安全性
- 不影响磁记录密度和提高磁盘利用率
- 提高RAID可靠性的措施是1.对磁盘进行镜像处理$\quad$ 2.奇偶校验

### Cache工作原理
![](/img/content/jizu_preview/cache_principle.jpg)

### 替换算法
- FIFO：先进先出，替换最先进来的（命中不改变顺序）
如：容量=3，依次插入ABCDBE，A->AB->ABC->BCD->BCD->CDE
- LRU：最近最久未使用，替换最就未被使用的（命中会将该元素优先级调到最高）
如：容量=3，依次插入ABCDBE，A->AB->ABC->BCD->CDB->DBE
- LFU：最少访问，根据访问的历史频率来淘汰数据

![](/img/content/jizu_preview/replace_algorithm.jpg)

### 写策略
- 全写法：命中时，同时修改Cache和主存中的数据
- 写回法：命中时，把数据写入Cache，当该块被替换时再写入主存
- 写分配法：不命中时，将主存块调入Cache，在Cache中修改，再搭配写回法
- 非写分配法：不命中时，直接修改主存中的数据

### 求Cache容量
![](/img/content/jizu_preview/cache_store.jpg)

### 知识点
- ROM和RAM的存取方式均为随机存取
- 存储器的3个主要性能指标：存储容量、单位成本、存储速度
- 数据传输率（主存带宽）=数据宽度/存储周期
- 存取时间$T_a$：从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间
- 存取周期$T_m$：存储器进行一次完整的读写操作所需的全部时间，即连续两次读或写操作之间所需的最小时间间隔
- 存取周期=存取时间+恢复时间
- 主存和Cache之间的数据调用对所有程序员透明
- 主存和辅存之间的数据调用对应用程序员透明
- CD-ROM是光盘，是只读型光盘存储器，采用串行存取方式
- RAM的速度比ROM速度快
- 芯片引脚=地址线+数据线+片选线1根+读写控制线1/2根
- DRAM采用地址复用技术：地址线减半，片选用行通选和列通选代替（2根）                                    
- ROM是随机存取，但不是随机存取存储器
- 低位交叉存储器满足程序的局部性原理
- 对于DRAM芯片，未减少刷新开销，应尽量使其存储阵列的行数和列数相等
- $磁盘数据传输率=磁盘转速(r/s)\times 转一圈经过的扇区\times 每个扇区的字节数$
- CPU与主存或Cache信息交换的的单位是字，Cache与主存信息交换的单位是块
- 地址映射表的大小：Cache行数$\times$(有效位1+标志位)
- CPU访存时，发送的是主存物理地址，不是缓存地址
- 时间局部性：一条指令执行完后，可能不久再次执行
- 空间局部性：一个存储单元被访问后，它附近的存储单元也很快被访问
- 采用指令Cache和数据Cache分离的目的是：减少指令流水冲突

## 第四章 指令系统
### 指令格式
![](/img/content/jizu_preview/instruction_format.jpg)

### 扩展操作码
- 使用频率高的指令分配短的操作码；使用频率低的指令分配长的操作码
- 目的：保持指令长度不变而增加指令数量

![](/img/content/jizu_preview/operation_extention.jpg)

### 设计指令系统
![](/img/content/jizu_preview/design_ins_sys.jpg)

### 操作码分类
- 程序控制类指令功能：改变程序执行顺序
- 程序控制指令包括：无条件转移、有条件转移、子程序调用、返回指令、循环指令等
![](/img/content/jizu_preview/opera_sort.jpg)

### 寻址方式
- 缩短指令字长
- 扩大寻址范围
- 提高编程灵活性
- 提高了指令译码的复杂度
$$
\begin{array}{|c|c|c|}
	\hline 寻址方式&说明&访存次数\\
	\hline 立即寻址&形式地址是操作数，即立即数&取指令1\\
	\hline 直接寻址&形式地址是操作数真实地址&取指令1+执行指令1\\
	\hline 间接寻址&形式地址访存2次为真实地址&取指令1+执行指令2\\
	\hline 寄存器寻址&形式地址是寄存器编号，与直接寻址对应&取指令1\\
	\hline 寄存器间接寻址&形式地址对应的寄存器的内容为真实地址&取指令1+执行指令1\\
	\hline 隐含寻址&给出一个操作数地址，另一个隐藏在ACC中&0\\
	\hline
\end{array}
$$

### 偏移寻址
- 基址寻址有利于多道程序设计
- 变址寻址适合编制循环程序（数组）
$$
\begin{array}{|c|c|c|c|}
	\hline 寻址方式&表达式&说明&面向\\
	\hline 基址寻址&EA=(BR)+A&有效地址=形式地址+基址寄存器&操作系统\\
	\hline 变址寻址&EA=(IX)+A&有效地址=形式地址+变址寄存器&用户\\
	\hline 相对寻址&EA=(PC)+A&有效地址=形式地址+PC寄存器&\\
	\hline
\end{array}
$$

### CISC和RISC
- RISC必然采用流水线技术，但CISC也可以采用流水线技术
- RISC普遍采用硬布线控制器，而非微程序控制器

![](/img/content/jizu_preview/cisc_risc.jpg)

### 知识点
- 指令系统是计算机硬件的语言系统，和机器语言有关
- 指令系统是计算机软/硬件的界面
- 中断隐指令由硬件实现，不是指令系统中的指令
- 特权指令仅用于操作系统或其他系统软件，不提供给用户使用
- 进栈：先压入数据，再修改指针；出栈：先修改指针，再弹出数据
- 跳跃寻址可以通过转移类指令（如相对寻址）实现，可用来实现程序的（无）条件转移
- 80-20规律：80%的语句只用到20%的指令

## 第五章 中央处理器

### CPU结构
- 用户可见的寄存器：通用寄存器、程序状态字寄存器PSW、程序计数器PC
- 用户不可见寄存器：MAR、MDR、IR、暂存寄存器
- 管理多条通路：多路选择器MUX与三态门
- MAR和MDR属于CPU

### 指令周期
![](/img/content/jizu_preview/instruction_cycle.jpg)

### 内部总线方式
- ALU只能有一个输入端与总线相连，另一个输入端需要通过暂存器与总线相连
- ALU的输出端通过暂存器与总线相连

![](/img/content/jizu_preview/inner_bus.jpg)

### 安排微操作时序的原则
- 微操作的先后顺序不得随意更改
- 被控对象不同的微操作尽量安排在一个节拍内完成
- 占用时间较短的微操作尽量安排在一个节拍内完成，并运行有先后顺序

### 流水线
![](/img/content/jizu_preview/liushuixian.jpg)

### 流水线计算
- 流水线吞吐率$T_p=\frac{n}{(k+n-1)\Delta t}$，k为一条指令的周期数，n为任务数量
- 流水线加速比$S=\frac{kn}{k+n-1}$，串行执行的时间/使用流水线的时间
- 流水线效率$E=\frac{T_0}{kT_k}$

![](/img/content/jizu_preview/liushuixian_calc.jpg)

### 知识点
- 通用寄存器是可编程指定多种功能的寄存器
- 指令译码仅对操作码字段进行译码（不包含地址码字段）
- 地址译码器是存储器中的结构，不属于CPU
- 间址周期是去操作数的有效地址，间址周期结束后，MDR的内容为操作数地址
- 指令周期：CPU从主存中取出并执行一条指令所需的全部时间
- 采用DMA方式传输数据时，每传送一个数据占用一个存取周期
- 指令总是根据PC从主存中读出
- CPU访存时间较长，机器周期通常由存取周期决定
- 执行各条指令的机器周期数可变、机器周期长度可变
- CPU响应中断的时间：一条指令执行结束
- 指令字长一般取字节或存储字长的整数倍，不一定都和存储字长一样大
- 单周期处理器：所有指令的指令周期为1个时钟周期的处理器
- 流水CPU采用时间并行技术而非空间并行技术
- 时钟周期以各功能段的最长执行时间为准
- 指令流水线数据通路不包括控制部件

